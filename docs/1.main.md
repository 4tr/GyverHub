# Документация GyverHub
### Оглавление
0. [Примеры](https://github.com/GyverLibs/GyverHub/tree/main/examples)
1. [Документация](https://github.com/GyverLibs/GyverHub/wiki)
2. [Начало работы](https://github.com/GyverLibs/GyverHub/wiki/2.-%D0%9D%D0%B0%D1%87%D0%B0%D0%BB%D0%BE-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B)
3. [Приложение](https://github.com/GyverLibs/GyverHub/wiki/3.-%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)
4. [Работа с библиотекой](https://github.com/GyverLibs/GyverHub/wiki/4.-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%BE%D0%B9)
5. [Дополнительно](https://github.com/GyverLibs/GyverHub/wiki/5.-%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE)
6. [Интеграция в умный дом](https://github.com/GyverLibs/GyverHub/wiki/6.-%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2-%D1%83%D0%BC%D0%BD%D1%8B%D0%B9-%D0%B4%D0%BE%D0%BC)
7. [Ручной режим](https://github.com/GyverLibs/GyverHub/wiki/7.-%D0%A0%D1%83%D1%87%D0%BD%D0%BE%D0%B9-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC)

[![Foo](https://img.shields.io/badge/ENGLISH-VERSION-blueviolet.svg?style=flat-square)](https://github-com.translate.goog/GyverLibs/GyverHub/wiki?_x_tr_sl=ru&_x_tr_tl=en)

## GyverHub
<details>
<summary>Компиляция</summary>

#### Платформа
Библиотека сама определяет, на какой платформе компилируется. Для ESP8266/ESP32 предусмотрен отдельный флаг `GH_ESP_BUILD` (библиотека сама его поднимает), включюащий сетевые возможности в компиляцию. Для создания кросс-платформенного кода можно "прятать" 
код для ESPxx внутри условной конструкции:

```cpp
#ifdef GH_ESP_BUILD
// этот код будет компилироваться только для esp
#endif
```

#### Дефайны настроек
```cpp
// Вводятся до подключения библиотеки
#define ATOMIC_FS_UPDATE  // OTA обновление GZIP файлом
#define GH_ASYNC          // использовать ASYNC библиотеки

// включить сайт в память программы (не нужно загружать файлы в память)
#define GH_INCLUDE_PORTAL

// полное отключение модулей из программы
#define GH_NO_PORTAL    // открытие сайта из памяти esp
#define GH_NO_WS        // WebSocket
#define GH_NO_MQTT      // MQTT
#define GH_NO_FS        // работа с файлами (включая ОТА!)
#define GH_NO_OTA       // ОТА файлом с приложения
#define GH_NO_OTA_URL   // ОТА по URL
```

</details>

<details>
<summary>Инициализация</summary>

Иконки Font Awesome v5 Solid, бесплатный пак:
- [Список иконок](https://fontawesome.com/v5/cheatsheet/free/solid)
- [Поиск иконок](https://fontawesome.com/v5/search?o=r&m=free&s=solid)

> Вставлять САМ СИМВОЛ в "строку", например `""` , `""` , `""`

```cpp
GyverHub;
GyverHub(char* prefix);                                         // + префикс сети
GyverHub(char* prefix, char* name);                             // + имя в списке устройств
GyverHub(char* prefix, char* name, char* icon);                 // + иконка в списке устройств
GyverHub(char* prefix, char* name, char* icon, uint32_t id);    // + вручную задать ID устройства
// примечание: id нужно обязательно задавать для отличных от ESP платформ (для esp генерируется автоматически)
// при задании id у esp он заменит сгенерированный библиотекой
```
</details>

<details>
<summary>Система</summary>

```cpp
// =================== CONFIG ==================
void config(char* nprefix, char* nname, char* nicon, uint32_t nid); // Аналог конструктора
void setVersion(char* v);   // установить версию прошивки для отображения в Info
void begin();               // запустить
void end();                 // остановить
bool tick();                // тикер, вызывать в loop

// ================== MODULES =================
// по умолчанию все модули включены
// модули, отвечающие за связь, нужно настраивать перед вызовом begin()!
void modules.set(uint16_t mods);    // включить модули
void modules.unset(uint16_t mods);  // выключить модули

// можно выбрать несколько модулей с разделителем | 
// modules.set(GH_MOD_DOWNLOAD | GH_MOD_UPLOAD | GH_MOD_INFO);
// modules.unset(GH_MOD_DOWNLOAD | GH_MOD_UPLOAD | GH_MOD_INFO);

bool modules.read(GHmodule_t mod);  // включен ли модуль
void modules.setAll();              // установить все
void modules.unsetAll();            // выключить все

// ==================== PIN ===================
void setPIN(uint32_t npin); // установить пин-код устройства (больше 1000, не может начинаться с 0)
uint32_t getPIN();          // прочитать пин-код

// =================== BUILD ==================
void onBuild(f);        // подключить сборщик интерфейса. Функция вида void f()
void refresh();         // обновить веб-интерфейс. Вызывать внутри обработчика build

// полные свойства
GHbuild getBuild();     // получить свойства текущего билда. Вызывать внутри обработчика build В САМОМ НАЧАЛЕ

// более простой доступ
bool buildRead();           // true - если билдер вызван для set или read операций
const GHaction& action();   // получить текущее действие для ручной обработки значений
// к результату можно применять name/nameString/value/valueInt/valueFloat/valueString

// ================== STATUS ==================
void onEvent(f);            // подключить обработчик изменения статуса. Функция вида void f(GHevent_t event, GHconn_t conn)
bool running();             // вернёт true, если система запущена
bool focused();             // true - интерфейс устройства сейчас открыт на сайте или в приложении
bool focused(GHconn_t c);   // проверить фокус по указанному типу связи

// подключить функцию-обработчик перезагрузки. Будет вызвана перед перезагрузкой. Функция вида void f(GHreason_t r)
// только для ESPxx
void onReboot(f);

// =================== CLI ===================
void onCLI(f);          // подключить обработчик входящих сообщений с веб-консоли. Функция вида void f(String& s)
void print(String s);   // отправить текст в веб-консоль
void print(String s, uint32_t color);    // + цвет

// ================= NOTIFY ==================
void sendPush(String text);                     // отправить пуш-уведомление

void sendAlert(String text);                    // показать всплывающее окно

void sendNotice(String text);                   // отправить всплывающее уведомление
void sendNotice(String text, uint32_t color);   // + цвет

// ================= UPDATE ==================
void sendUpdate(String name, String value);     // отправить update вручную с указанием значения

// отправить update по имени компонента (значение будет прочитано в build)
// имена можно передать списком через запятую
// нельзя вызывать внутри build
void sendUpdate(String name);

// ================= CANVAS =================
void sendCanvas(String name, GHcanvas& cv);       // отправить холст
void sendCanvasBegin(String name, GHcanvas& cv);  // начать отправку холста
void sendCanvasEnd(GHcanvas& cv);                        // закончить отправку холста

// ================== MQTT ==================
// настроить MQTT (только TCP)
void setupMQTT(char* host, uint16_t port);
void setupMQTT(char* host, uint16_t port, char* login, const char* pass);
void setupMQTT(char* host, uint16_t port, char* login, const char* pass, uint8_t qos, bool retained);

void setupMQTT(IPAddress ip, uint16_t port);
void setupMQTT(IPAddress ip, uint16_t port, char* login, const char* pass);
void setupMQTT(IPAddress ip, uint16_t port, char* login, const char* pass, uint8_t qos, bool retained);
// для игнорирования login/pass нужно установить 0

bool online();      // MQTT подключен

void turnOn();      // отправить MQTT LWT команду на включение
void turnOff();     // отправить MQTT LWT команду на выключение

void sendGetAuto(bool v);       // автоматически отправлять новое состояние на get-топик при изменении через set (умолч. false)
void sendGet(String name, String value);    // отправить имя-значение на get-топик (MQTT)

// отправить значение по имени компонента на get-топик (MQTT) (значение будет прочитано в build)
// имена можно передать списком через запятую
// нельзя вызывать внутри build
void sendGet(String name);

// ============== MANUAL BUILD ==============
void onManual(f);                                   // подключить обработчик запроса при ручном соединении. Функция вида void f(String& s, GHconn_t conn, bool broadcast)
void parse(char* url, GHconn_t conn);               // парсить команду вида PREFIX/ID/HUB_ID/CMD/NAME=VALUE, указать тип подключения
void parse(char* url, char* var, GHconn_t conn);    // парсить команду вида PREFIX/ID/HUB_ID/CMD/NAME, value отдельно, указать тип подключения

// установить размер буфера строки для сборки интерфейса в режиме MANUAL
// 0 - интерфейс будет собран и отправлен цельной строкой, иначе пакет будет отправляться частями размером с буфер
void setBufferSize(uint16_t size);
```
</details>

## Конструктор
<details>
<summary>Условные обозначения</summary>

- `String` - для краткости под этим типом подразумевается `String`. По умолчанию может иметь значение пустой строки - `""`
    - `func("текст в кавычках");`  - строки const char*
    - `func(F("строка в flash"));` - строки, сохранённые в Flash памяти через F() - `F("строка")`
    - `String s; func(s);`         - String строки, объявленные выше
    - `func(String(123) + 456);`   - String строки, объявленные внутри (не рекомендуется)
- `FSTR` - для краткости под этим типом подразумевается `const __FlashStringHelper*` - строки, сохранённые в Flash памяти. Вызов: `func(F("F-строка"));`. Так как это указатель, по умолчанию может иметь значение `0` или `nullptr`
- `ИМЯ` - уникальное имя компонента. Строка в любом виде (оптимальнее всего - `F("строка")`)
- `НАЗВАНИЕ` - название блока (подпись). Строка в любом виде (оптимальнее всего - `F("строка")`). Чтобы полностью убрать название, нужно передать константу `GH_NO_LABEL`
- `ЦВЕТ` - цвет компонента типа `uint32_t` или `GHcolor`. Можно передать цвет из стандартного списка цветов `GH_RED`, `GH_BLUE`... (см. ниже)
- `void* var` - переменная *любого типа*, переданная в функцию по адресу. Компоненты сами изменяют значения переменных при действиях с приложения. Если автоматическое изменение не нужно - передай `0` вместо адреса
- `ТИП` - тип "подключенной" в предыдущем аргументе переменной. Смотри типы `GHdata_t` ниже. Если переменная не передана (передан `0`), тип можно указать `GH_NULL`

> Разница между функциями с `FSTR` и `String` - использование F-строк в функции компонента приводит к вызову более оптимального с точки зрения использования оперативной памяти варианта функции компонента
</details>

<details>
<summary>Компоненты</summary>

```cpp
// ========================== ВИДЖЕТ ==========================
void BeginWidgets();            // начать строку виджетов
void BeginWidgets(int высота);  // + указать минимальную высоту в px
void EndWidgets();              // завершить строку виджетов
void WidgetSize(int ширина);    // ширина следующего виджета

// ======================== ОФОРМЛЕНИЕ ========================
void Space();                   // пустое место (в режиме виджетов - пустой виджет)
void Space(int высота);         // + настройка высоты в px

void Title(FSTR label);         // заголовок
void Title(String label);       // заголовок

// ===================== ПАССИВНЫЙ ТЕКСТ ======================
// крупный цветной текст
void Label(ИМЯ, String текст, НАЗВАНИЕ, ЦВЕТ, int размер);
void Label(FSTR name, String value = "", FSTR label = 0, uint32_t color = GH_DEFAULT, int size = 40);
void Label(String name, String value = "", String label = "", uint32_t color = GH_DEFAULT, int size = 40);

// дисплей. Для переноса строк используй символ '\n'
void Display(ИМЯ, String текст, НАЗВАНИЕ, ЦВЕТ, int строк, int размер);
void Display(FSTR name, FSTR value = 0, FSTR label = 0, uint32_t color = GH_DEFAULT, int rows = 2, int size = 40);
void Display(String name, String value = "", String label = "", uint32_t color = GH_DEFAULT, int rows = 2, int size = 40);

// блок для HTML кода
void HTML(ИМЯ, String текст, НАЗВАНИЕ);
void HTML(FSTR name, FSTR value = 0, FSTR label = 0);
void HTML(String name, String value = "", String label = "");

// ========================== SCRIPT ===========================
// JavaScript код, будет исполнен в eval()
void JS(FSTR value = 0);
void JS(String value = "");

// ============================ LOG =============================
// вывод лога
void Log(ИМЯ, GHlog* log, НАЗВАНИЕ);
void Log(FSTR name, GHlog* log, FSTR label = 0);
void Log(String name, GHlog* log, String label = "");

// ========================= ИНДИКАЦИЯ ==========================
// светодиод
void LED(ИМЯ, bool value, НАЗВАНИЕ, String иконка);
void LED(FSTR name, bool value = 0, FSTR label = 0, FSTR icon = 0);
void LED(String name, bool value = 0, String label = "", String icon = "");

// индикаторная шкала
// здесь текст - будет выведен после значения (например "°C")
void Gauge(ИМЯ, float value, String текст, НАЗВАНИЕ, минимум, максимум, шаг, ЦВЕТ);
void Gauge(FSTR name, float value = 0, FSTR text = 0, FSTR label = 0, float minv = 0, float maxv = 100, float step = 1, uint32_t color = GH_DEFAULT);
void Gauge(String name, float value = 0, String text = "", String label = "", float minv = 0, float maxv = 100, float step = 1, uint32_t color = GH_DEFAULT);

// ======================== ВКЛАДКИ ==========================
// вкладки, передать список пунктов через запятую
bool Tabs(ИМЯ, uint8_t* var, String список, НАЗВАНИЕ);
bool Tabs(FSTR name, uint8_t* var, FSTR text, FSTR label = 0);
bool Tabs(String name, uint8_t* var, String text, String label = "");

// ========================== МЕНЮ ============================
// выпадающее меню устройства, передать список пунктов через запятую
// номер текущего пункта хранится в переменной menu - член класса GyverHub
bool Menu(String список);

// ========================== КНОПКИ ==========================
// кнопка с текстом
bool Button(ИМЯ, bool* var, НАЗВАНИЕ, ЦВЕТ, int размер_текста);
bool Button(FSTR name, bool* var = 0, FSTR label = 0, uint32_t color = GH_DEFAULT, int size = 22);
bool Button(String name, bool* var = 0, String label = "", uint32_t color = GH_DEFAULT, int size = 22);

// кнопка с иконкой
bool ButtonIcon(ИМЯ, bool* var, НАЗВАНИЕ, ЦВЕТ, int размер_текста);
bool ButtonIcon(FSTR name, bool* var = 0, FSTR label = 0, uint32_t color = GH_DEFAULT, int size = 50);
bool ButtonIcon(String name, bool* var = 0, String label = "", uint32_t color = GH_DEFAULT, int size = 50);

// =========================== ВВОД ===========================
// ввод любых данных
bool Input(ИМЯ, void* var, ТИП, НАЗВАНИЕ, int макс_символов, ЦВЕТ);
bool Input(FSTR name, void* var = 0, GHdata_t type = GH_NULL, FSTR label = 0, int maxv = 0, uint32_t color = GH_DEFAULT);
bool Input(String name, void* var = 0, GHdata_t type = GH_NULL, String label = "", int maxv = 0, uint32_t color = GH_DEFAULT);

// пароль
bool Pass(ИМЯ, void* var, ТИП, НАЗВАНИЕ, int макс_символов, ЦВЕТ);
bool Pass(FSTR name, void* var = 0, GHdata_t type = GH_NULL, FSTR label = 0, int maxv = 0, uint32_t color = GH_DEFAULT);
bool Pass(String name, void* var = 0, GHdata_t type = GH_NULL, String label = "", int maxv = 0, uint32_t color = GH_DEFAULT);

// слайдер
bool Slider(ИМЯ, void* var, ТИП, НАЗВАНИЕ, минимум, максимум, шаг, ЦВЕТ);
bool Slider(FSTR name, void* var = 0, GHdata_t type = GH_NULL, FSTR label = 0, float minv = 0, float maxv = 100, float step = 1, uint32_t color = GH_DEFAULT);
bool Slider(String name, void* var = 0, GHdata_t type = GH_NULL, String label = "", float minv = 0, float maxv = 100, float step = 1, uint32_t color = GH_DEFAULT);

// спиннер
bool Spinner(ИМЯ, void* var, ТИП, НАЗВАНИЕ, минимум, максимум, шаг, ЦВЕТ);
bool Spinner(FSTR name, void* var = 0, GHdata_t type = GH_NULL, FSTR label = 0, float minv = 0, float maxv = 100, float step = 1, uint32_t color = GH_DEFAULT);
bool Spinner(String name, void* var = 0, GHdata_t type = GH_NULL, String label = "", float minv = 0, float maxv = 100, float step = 1, uint32_t color = GH_DEFAULT);

// джойстик
bool Joystick(ИМЯ, GHpos* pos, bool авто_центр, bool экспонента, НАЗВАНИЕ, ЦВЕТ);
bool Joystick(FSTR name, GHpos* pos, bool autoc = 1, bool exp = 0, FSTR label = 0, uint32_t color = GH_DEFAULT);
bool Joystick(String name, GHpos* pos, bool autoc = 1, bool exp = 0, String label = "", uint32_t color = GH_DEFAULT);

// всплывающее окно ввода
// для активации отправь sendUpdate() с именем и пустой строкой или новым текстом для окна
bool Prompt(FSTR name, void* var, ТИП, НАЗВАНИЕ);
bool Prompt(FSTR name, void* var = 0, GHdata_t type = GH_NULL, FSTR label = 0);
bool Prompt(String name, void* var = 0, GHdata_t type = GH_NULL, String label = "");

// ======================== ВЫКЛЮЧАТЕЛИ ========================
// выключатель
bool Switch(ИМЯ, bool* var, НАЗВАНИЕ, ЦВЕТ);
bool Switch(FSTR name, bool* var = 0, FSTR label = 0, uint32_t color = GH_DEFAULT);
bool Switch(String name, bool* var = 0, String label = "", uint32_t color = GH_DEFAULT);

// выключатель-иконка
bool SwitchIcon(ИМЯ, bool* var, НАЗВАНИЕ, String текст, ЦВЕТ);
bool SwitchIcon(FSTR name, bool* var = 0, FSTR label = 0, FSTR text = 0, uint32_t color = GH_DEFAULT);
bool SwitchIcon(String name, bool* var = 0, String label = "", String text = "", uint32_t color = GH_DEFAULT);

// выключатель-текст
bool SwitchText(ИМЯ, bool* var, НАЗВАНИЕ, String текст, ЦВЕТ);
bool SwitchText(FSTR name, bool* var = 0, FSTR label = 0, FSTR text = 0, uint32_t color = GH_DEFAULT);
bool SwitchText(String name, bool* var = 0, String label = "", String text = "", uint32_t color = GH_DEFAULT);

// всплывающее окно с кнопками ОК и ОТМЕНА
// для активации отправь sendUpdate() с именем и пустой строкой или новым текстом для окна
bool Confirm(ИМЯ, bool* var, НАЗВАНИЕ);
bool Confirm(FSTR name, bool* var = 0, FSTR label = 0);
bool Confirm(String name, bool* var = 0, String label = "");

// =========================== ВРЕМЯ ===========================
// подключается переменная, хранящая unix-время
// ввод даты
bool Date(ИМЯ, uint32_t* var, НАЗВАНИЕ, ЦВЕТ);
bool Date(FSTR name, uint32_t* var, FSTR label = 0, uint32_t color = GH_DEFAULT);
bool Date(String name, uint32_t* var, String label = "", uint32_t color = GH_DEFAULT);

// ввод времени
bool Time(ИМЯ, uint32_t* var, НАЗВАНИЕ, ЦВЕТ);
bool Time(FSTR name, uint32_t* var, FSTR label = 0, uint32_t color = GH_DEFAULT);
bool Time(String name, uint32_t* vavarlue, String label = "", uint32_t color = GH_DEFAULT);

// ввод даты и времени
bool DateTime(ИМЯ, uint32_t* var, НАЗВАНИЕ, ЦВЕТ);
bool DateTime(FSTR name, uint32_t* var, FSTR label = 0, uint32_t color = GH_DEFAULT);
bool DateTime(String name, uint32_t* var, String label = "", uint32_t color = GH_DEFAULT);

// =========================== ВЫБОР ===========================
// выбор, передать список пунктов через запятую
bool Select(ИМЯ, uint8_t* var, String список, НАЗВАНИЕ, ЦВЕТ);
bool Select(FSTR name, uint8_t* var, FSTR text, FSTR label = 0, uint32_t color = GH_DEFAULT);
bool Select(String name, uint8_t* var, String text, String label = "", uint32_t color = GH_DEFAULT);

// флаги, передать список пунктов через запятую
bool Flags(ИМЯ, GHflags* var, String текст, НАЗВАНИЕ, ЦВЕТ);
bool Flags(FSTR name, GHflags* var = 0, FSTR text = 0, FSTR label = 0, uint32_t color = GH_DEFAULT);
bool Flags(String name, GHflags* var = 0, String text = "", String label = "", uint32_t color = GH_DEFAULT);

// цвет
bool Color(ИМЯ, GHcolor* var, НАЗВАНИЕ);
bool Color(FSTR name, GHcolor* var = 0, FSTR label = 0);
bool Color(String name, GHcolor* var = 0, String label = "");

// ========================== CANVAS ===========================
// размеры холста по умолч. 400x300px
// пустой холст
bool Canvas(ИМЯ, ШИРИНА, ВЫСОТА, GHcanvas* cv, GHpos* pos, НАЗВАНИЕ);
bool Canvas(FSTR name, int width = 400, int height = 300, GHcanvas* cv = 0, GHpos* pos = 0, FSTR label = 0);
bool Canvas(String name, int width = 400, int height = 300, GHcanvas* cv = 0, GHpos* pos = 0, String label = "");

// начать холст с рисунком
bool BeginCanvas(ИМЯ, ШИРИНА, ВЫСОТА, GHcanvas* cv, GHpos* pos, НАЗВАНИЕ);
bool BeginCanvas(FSTR name, int width = 400, int height = 300, GHcanvas* cv = 0, GHpos* pos = 0, FSTR label = 0);
bool BeginCanvas(String name, int width = 400, int height = 300, GHcanvas* cv = 0, GHpos* pos = 0, String label = "");

// закончить холст с рисунком
void EndCanvas();

// =========================== DUMMY ===========================
// пустой компонент, не отображается в интерфейсе
// может быть опрошен и установлен через MQTT и прямые запросы API
bool Dummy(ИМЯ, void* var, ТИП);
bool Dummy(FSTR name, void* var = 0, GHdata_t type = GH_NULL);
bool Dummy(String name, void* var = 0, GHdata_t type = GH_NULL);
```
</details>

<details>
<summary>Цвет</summary>

```cpp
GH_RED      // 0xcb2839
GH_ORANGE   // 0xd55f30
GH_YELLOW   // 0xd69d27
GH_GREEN    // 0x37A93C
GH_MINT     // 0x25b18f
GH_AQUA     // 0x2ba1cd
GH_BLUE     // 0x297bcd
GH_VIOLET   // 0x825ae7
GH_PINK     // 0xc8589a
```
</details>

## Canvas API
<details>
<summary>GHcanvas</summary>

```cpp
void extBuffer(String* sptr);   // подключить внешний буфер
void clearBuffer();             // очистить буфер (внутренний)
void custom(String s);          // добавить строку кода на js
```
</details>

<details>
<summary>Processing API</summary>

https://processing.org/reference/
```cpp
// =============== BACKGROUND ===============
void clear();                           // очистить полотно
void background();                      // залить полотно установленным в fill() цветом
void background(uint32_t hex);          // залить полотно указанным цветом
void background(uint32_t hex, a);       // залить полотно указанным цветом + прозрачность 0-255

// ================== FILL ==================
void noFill();                          // отключить заливку (по умолч. вкл)
void fill(uint32_t hex);                // выбрать цвет заливки
void fill(uint32_t hex, uint8_t a);     // выбрать цвет заливки + прозрачность 0-255

// ================= STROKE =================
void noStroke();                        // отключить обводку (по умолч. вкл)
void stroke(uint32_t hex);              // выбрать цвет обводки
void stroke(uint32_t hex, uint8_t a);   // выбрать цвет обводки + прозрачность 0-255
void strokeWeight(int v);               // толщина обводки, px

// соединение линий: CV_MITER (умолч), CV_BEVEL, CV_ROUND
// https://processing.org/reference/strokeJoin_.html
void strokeJoin(v);

// края линий: CV_PROJECT (умолч), CV_ROUND, CV_SQUARE
// https://processing.org/reference/strokeCap_.html
void strokeCap(v);

// =============== PRIMITIVES ===============
void point(int x, int y);               // точка
void circle(int x, int y, int r);       // окружность (x, y, радиус), px
void line(int x1, int y1, int x2, int y2);  // линия (координаты начала и конца)
void square(int x, int y, int w);       // квадрат
void rect(int x, int y, int w, int h);  // прямоугольник
void triangle(int x1, int y1, int x2, int y2, int x3, int y3);  // треугольник (координаты углов)
void quadrangle(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);    // четырёхугольник (координаты углов)

// режим окружности: CV_CENTER (умолч), CV_CORNER
// https://processing.org/reference/ellipseMode_.html
void ellipseMode(mode);

// режим прямоугольника: CV_CORNER (умолч), CV_CORNERS, CV_CENTER, CV_RADIUS
// https://processing.org/reference/rectMode_.html
void rectMode(mode);

// ================== TEXT ==================
void text(String text, int x, int y, int w = 0); // вывести текст, опционально макс длина
void textFont(const char* name);    // шрифт
void textSize(int size);            // размер шрифта, px

// выравнивание текста
// h: CV_LEFT, CV_CENTER, CV_RIGHT
// v: TXT_TOP, TXT_BOTTOM, TXT_CENTER, TXT_BASELINE
// https://processing.org/reference/textAlign_.html
void textAlign(h, v);

// ================= SYSTEM =================
void push();    // сохранить конфигурацию полотна
void pop();     // восстановить конфигурацию полотна
```
</details>

<details>
<summary>HTML API</summary>

https://www.w3schools.com/tags/ref_canvas.asp

```cpp
void fillStyle(uint32_t hex);               // цвет заполнения
void fillStyle(uint32_t hex, uint8_t a);    // цвет заполнения

void strokeStyle(uint32_t hex);             // цвет обводки
void strokeStyle(uint32_t hex, uint8_t a);  // цвет обводки

void shadowColor(uint32_t hex);             // цвет тени
void shadowColor(uint32_t hex, uint8_t a);  // цвет тени

void shadowBlur(int v);         // размытость тени, px
void shadowOffsetX(int v);      // отступ тени, px
void shadowOffsetY(int v);      // отступ тени, px

// края линий: CV_BUTT (умолч), CV_ROUND, CV_SQUARE
// https://www.w3schools.com/tags/canvas_linecap.asp
void lineCap(v);

// соединение линий: CV_MITER (умолч), CV_BEVEL, CV_ROUND
// https://www.w3schools.com/tags/canvas_linejoin.asp
void lineJoin(v);

// ширина линий, px
void lineWidth(int v);

// длина соединения CV_MITER, px
// https://www.w3schools.com/tags/canvas_miterlimit.asp
void miterLimit(int v);

// шрифт: "30px Arial"
// https://www.w3schools.com/tags/canvas_font.asp
void font(String v);

// выравнивание текста: CV_START (умолч), CV_END, CV_CENTER, CV_LEFT, CV_RIGHT
// https://www.w3schools.com/tags/canvas_textalign.asp
void textAlign(v);

// позиция текста: CV_ALPHABETIC (умолч), CV_TOP, CV_HANGING, CV_MIDDLE, CV_IDEOGRAPHIC, CV_BOTTOM
// https://www.w3schools.com/tags/canvas_textbaseline.asp
void textBaseline(v);

// прозрачность рисовки, 0.0-1.0
void globalAlpha(float v);

// тип наложения графики: CV_SRC_OVER (умолч), CV_SRC_ATOP, CV_SRC_IN, CV_SRC_OUT, CV_DST_OVER, CV_DST_ATOP, CV_DST_IN, CV_DST_OUT, CV_LIGHTER, CV_COPY, CV_XOR
// https://www.w3schools.com/tags/canvas_globalcompositeoperation.asp
void globalCompositeOperation(v);

void drawRect(int x, int y, int w, int h);      // прямоугольник (в HTML API это rect)
void fillRect(int x, int y, int w, int h);      // закрашенный прямоугольник
void strokeRect(int x, int y, int w, int h);    // обведённый прямоугольник
void clearRect(int x, int y, int w, int h);     // очистить область
void fill();                                    // залить
void stroke();                                  // обвести
void beginPath();                               // начать путь
void moveTo(int x, int y);                      // переместить курсор
void closePath();                               // завершить путь (провести линию на начало)
void lineTo(int x, int y);                      // нарисовать линию от курсора

// ограничить область рисования
// https://www.w3schools.com/tags/canvas_clip.asp
void clip();

// провести кривую
// https://www.w3schools.com/tags/canvas_quadraticcurveto.asp
void quadraticCurveTo(int cpx, int cpy, int x, int y);

// провести кривую Безье
// https://www.w3schools.com/tags/canvas_beziercurveto.asp
void bezierCurveTo(int cp1x, int cp1y, int cp2x, int cp2y, int x, int y);

// провести дугу
// https://www.w3schools.com/tags/canvas_arc.asp
void arc(int x, int y, int r, int sa = 0, int ea = 360, bool ccw = 0);

// скруглить
// https://www.w3schools.com/tags/canvas_arcto.asp
void arcTo(int x1, int y1, int x2, int y2, int r);

// масштабировать область рисования
// https://www.w3schools.com/tags/canvas_scale.asp
void scale(int sw, int sh);

// вращать область рисования
// https://www.w3schools.com/tags/canvas_rotate.asp
void rotate(int v);

// перемещать область рисования
// https://www.w3schools.com/tags/canvas_translate.asp
void translate(int x, int y);

// вывести закрашенный текст, опционально макс. длина
void fillText(String text, int x, int y, int w = 0);

// вывести обведённый текст, опционально макс. длина
void strokeText(String text, int x, int y, int w = 0);

// вывести картинку
// https://www.w3schools.com/tags/canvas_drawimage.asp
void drawImage(String img, int x, int y);
void drawImage(String img, int x, int y, int w, int h);
void drawImage(String img, int sx, int sy, int sw, int sh, int x, int y, int w, int h);

// сохранить конфигурацию полотна
// https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/save
void save();

// восстановить конфигурацию полотна
// https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore
void restore();
```
</details>

<details>
<summary>Обработка геометрии</summary>

```cpp
// расстояние между двумя точками
int16_t GHdist(int16_t x0, int16_t y0, int16_t x1, int16_t y1);

// точка xy лежит внутри прямоугольника (координаты угла и размеры)
bool GHinRect(int16_t x, int16_t y, int16_t rx, int16_t ry, int16_t w, int16_t h);

// точка xy лежит внутри окружности (координаты центра и радиус)
bool GHinCircle(int16_t x, int16_t y, int16_t cx, int16_t cy, int16_t r);
```
</details>

## Вспомогательные классы
#### Stamp
Удобное ханение и преобразование даты и времени, устанавливается и подключается как [отдельная библиотека](https://github.com/GyverLibs/Stamp)

<details>
<summary>GHlog</summary>

"Printable" текстовый буфер для ведения оффлайн логов
```cpp
// в лог можно делать print()/println()
void begin(int n = 64);     // начать и указать размер буфера
void end();                 // остановить
void read(String* s);       // прочитать в строку
String read();              // прочитать строкой
void clear();               // очистить
bool available();           // есть данные
bool state();               // запущен
int length();               // длина
```
</details>

<details>
<summary>GHpos</summary>

Хранение позиции для обработки джойстика и холста
```cpp
// конструктор
GHpos(int16_t x, int16_t y);

// координаты
int16_t x;
int16_t y;

// индикатор того, что координаты изменились
// автоматически сбросится в false
bool changed();

// вспомогательные функции для холста
// расстояние до точки
int16_t dist(int16_t x1, int16_t y1);

// точка лежит внутри прямоугольника
bool inRect(int16_t rx, int16_t ry, int16_t w, int16_t h);

// точка лежит внутри окружности
bool inCircle(int16_t cx, int16_t cy, int16_t r);
```
</details>

<details>
<summary>GHcolor</summary>

Хранение и преобразование цвета
```cpp
// содержит 3 компонента цвета
uint8_t r;
uint8_t g;
uint8_t b;

// конструктор
GHcolor(uint32_t col);
GHcolor(uint8_t nr, uint8_t ng, uint8_t nb);

// установить
void setRGB(uint8_t nr, uint8_t ng, uint8_t nb);
void setHEX(uint32_t hex);

// преобразовать в 24-бит цвет
uint32_t getHEX();
```
</details>

<details>
<summary>GHflags</summary>

Хранение однобитных флагов, максимум 16 штук
```cpp
uint16_t flags;

GHflags(uint16_t nflags);

// установить флаг под номером idx в значение val
void set(uint8_t idx, uint8_t val);

// получить значение флага под номером idx
uint8_t get(uint8_t idx);

// вывести строкой вида 010101010
String toString();
```
</details>

<details>
<summary>GHtimer</summary>

Простенький периодический таймер на millis()
```cpp
// конструктор
GHtimer();      // без запуска

// сразу запустить
GHtimer(uint32_t ms = 0, uint8_t seconds = 0, uint8_t minutes = 0, uint8_t hours = 0, uint8_t days = 0);

// запуск
void start();
void start(uint32_t ms);
void start(uint32_t ms, uint8_t seconds);
void start(uint32_t ms, uint8_t seconds, uint8_t minutes);
void start(uint32_t ms, uint8_t seconds, uint8_t minutes, uint8_t hours);
void start(uint32_t ms, uint8_t seconds, uint8_t minutes, uint8_t hours, uint8_t days);

void stop();    // остановить
bool ready();   // таймер сработал
```
</details>

<details>
<summary>GHbuild</summary>

Информация о билде
```cpp
GHbuild_t type;     // тип билда
GHhub hub;          // данные клиента
GHaction action;    // действие
```
</details>

<details>
<summary>GHhub</summary>

Информация о клиенте
```cpp
GHconn_t conn;      // тип соединения
char id[9];         // id клиента
```
</details>

<details>
<summary>GHaction</summary>

Информация о действии
```cpp
GHaction_t type;        // тип действия 

const char* name;       // имя компонента
String nameString();    // имя как String

const char* value;      // значение компонента
String valueString();   // значение как String
int32_t valueInt();     // значение как int (32 бит)
float valueFloat();     // значение как float
```
</details>

## Типы данных
<details>
<summary>GHdata_t (тип переменной)</summary>

```cpp
GH_NULL     // нет

GH_STR      // String
GH_CSTR     // char[]

GH_BOOL     // bool
GH_INT8     // int8_t
GH_UINT8    // uint8_t
GH_INT16    // int16_t
GH_UINT16   // uint16_t
GH_INT32    // int32_t
GH_UINT32   // uint32_t

GH_FLOAT    // float
GH_DOUBLE   // double
```
</details>

<details>
<summary>GHreason_t (причина перезагрузки)</summary>

```cpp
GH_REB_NONE         // нет
GH_REB_BUTTON       // по кнопке с сайта
GH_REB_OTA          // после ОТА обновления
GH_REB_OTA_URL      // после OTA обновления по URL
```

Для чтения как текст (`FlashStringHelper`) можно использовать функцию:
```cpp
FSTR GHreadReason(GHreason_t n);
```
</details>

<details>
<summary>GHbuild_t (тип билда)</summary>

```cpp
GH_BUILD_NONE       // нет
GH_BUILD_ACTION     // действие GHaction_t
GH_BUILD_COUNT      // измерение размера пакета
GH_BUILD_READ       // чтение значения по имени (get, update)
GH_BUILD_UI         // сборка интерфейса для отправки
GH_BUILD_TG         // сборка для Telegram
```

Для чтения как текст (`FlashStringHelper`) можно использовать функцию:
```cpp
FSTR GHreadBuild(GHbuild_t n);
```
</details>

<details>
<summary>GHaction_t (тип действия)</summary>

```cpp
GH_ACTION_NONE      // нет
GH_ACTION_SET       // установка значения
GH_ACTION_PRESS     // кнопка нажата
GH_ACTION_RELEASE   // кнопка отпущена
```

Для чтения как текст (`FlashStringHelper`) можно использовать функцию:
```cpp
FSTR GHreadAction(GHaction_t n);
```
</details>

<details>
<summary>GHconn_t (тип подключения)</summary>

```cpp
GH_SERIAL   // Serial
GH_BT       // Bluetooth
GH_WS       // WebSocket
GH_MQTT     // MQTT
GH_SYSTEM   // системное событие
```

Для чтения как текст (`FlashStringHelper`) можно использовать функцию:
```cpp
FSTR GHreadConn(GHconn_t n);
```
</details>

<details>
<summary>GHmodule_t (отключаемые модули)</summary>

```cpp
GH_MOD_INFO     // разрешить вкладку инфо
GH_MOD_FSBR     // разрешить вкладку менеджера файлов
GH_MOD_FORMAT   // разрешить форматирование FS
GH_MOD_DOWNLOAD // разрешить скачивание
GH_MOD_UPLOAD   // разрешить загрузку
GH_MOD_OTA      // разрешить ОТА
GH_MOD_OTA_URL  // разрешить ОТА по URL
GH_MOD_REBOOT   // разрешить перезагрузку из инфо
GH_MOD_SET      // разрешить установку значений
GH_MOD_CLICK    // разрешить клики
GH_MOD_READ     // разрешить чтение
GH_MOD_DELETE   // разрешить удаление файлов
GH_MOD_RENAME   // разрешить переименование файлов
```
</details>

<details>
<summary>GHevent_t (системное событие)</summary>

```cpp
GH_IDLE
GH_START
GH_STOP

GH_CONNECTING
GH_CONNECTED
GH_DISCONNECTED
GH_ERROR

GH_UNKNOWN
GH_DISCOVER_ALL
GH_DISCOVER
GH_FOCUS
GH_UNFOCUS

GH_SET
GH_CLICK
GH_CLI
GH_PING

GH_READ_HOOK
GH_SET_HOOK
GH_INFO
GH_REBOOT
GH_FSBR
GH_FORMAT
GH_DELETE
GH_RENAME

GH_DOWNLOAD
GH_DOWNLOAD_CHUNK
GH_DOWNLOAD_ERROR
GH_DOWNLOAD_ABORTED
GH_DOWNLOAD_FINISH

GH_UPLOAD
GH_UPLOAD_CHUNK
GH_UPLOAD_ERROR
GH_UPLOAD_ABORTED
GH_UPLOAD_FINISH

GH_OTA
GH_OTA_CHUNK
GH_OTA_ERROR
GH_OTA_ABORTED
GH_OTA_FINISH

GH_OTA_URL
```

Для чтения как текст (`FlashStringHelper`) можно использовать функцию:
```cpp
FSTR GHreadEvent(GHevent_t n);
```
</details>


## API

<details>
<summary>Условные обозначения</summary>

| Имя      | Значение                |
|:---------|:------------------------|
| `PREFIX` | префикс сети            |
| `HUB_ID` | ID клиента (8 символов) |
| `ID`     | ID устройства           |
| `CMD`    | команда                 |
| `NAME`   | имя команды             |
| `VALUE`  | значение                |

</details>

<details>
<summary>MQTT топики</summary>

#### Для подписки
| topic                     | value                     | Описание        |
|:--------------------------|:--------------------------|:----------------|
| `PREFIX/hub/ID/get/NAME`  | `VALUE`                   | get-топик       |
| `PREFIX/hub/ID/status`    | `'online'`<br>`'offline'` | Статус топик    |

#### Для отправки
| topic                        | value   | Описание                |
|:-----------------------------|:--------|:------------------------|
| `PREFIX/ID/read/NAME`        |         | Прочиать (в get-топик)  |
| `PREFIX/ID/set/NAME`         | `VALUE` | Установить              |

</details>

<details>
<summary>Команды API</summary>

### MQTT
#### Для подписки

| topic                 | Описание          |
|:----------------------|:------------------|
| `PREFIX/hub`          | Broadcast ответы  |
| `PREFIX/hub/HUB_ID/#` | Ответы клиенту    |
| `PREFIX/hub/ID/get/#` | get топик         |

#### Для отправки

| topic                       | value    | Ответ        | Описание               |
|:----------------------------|:---------|:-------------|:-----------------------|
| `PREFIX`                    | `HUB_ID` | `{discover}` | discover all           |
| `PREFIX/ID`                 | `HUB_ID` | `{discover}` | discover               |
| `PREFIX/ID/HUB_ID/CMD`      |          | `{...}`      | command                |
| `PREFIX/ID/HUB_ID/CMD/NAME` |          | `{...}`      | command + name         |
| `PREFIX/ID/HUB_ID/CMD/NAME` | `VALUE`  | `{...}`      | command + name + value |

### HTTP hook
Для использования WS обнаружения через HTTP hook устройство должно ответить на HTTP запрос `/hub_discover_all` на 80 порту ответом `OK`.

### URL

| URL                               | Ответ        | Описание               |
|:----------------------------------|:-------------|:-----------------------|
| `PREFIX`                          | `{discover}` | discover all           |
| `PREFIX/ID`                       | `{discover}` | discover               |
| `PREFIX/ID/HUB_ID/CMD`            | `...`        | command                |
| `PREFIX/ID/HUB_ID/CMD/NAME`       | `...`        | command + name         |
| `PREFIX/ID/HUB_ID/CMD/NAME=VALUE` | `...`        | command + name + value |

### Команды

| CMD           | Ответ                                 | Описание          |
|:--------------|:--------------------------------------|:------------------|
| `focus`       | `{ui}`                                | Запрос интерфейса |
| `ping`        | `{OK}`                                | Пинг              |
| `unfocus`     |                                       | Закрыть           |
| `info`        | `{info}`<br>`{ERR}`                   | Вкладка инфо      |
| `fsbr`        | `{fsbr}`<br>`{ERR}`<br>`{fs_error}`   | Вкладка файлов    |
| `format`      | `{OK}`<br>`{ERR}`                     | Форматировать FS  |
| `reboot`      | `{OK}`<br>`{ERR}`                     | Перезагрузить     |
| `fetch_chunk` | `{fetch_next_chunk}`<br>`{fetch_err}` | Скачивание        |


| CMD            | NAME                 | VALUE                  | Ответ                                | Описание                       |
|:---------------|:---------------------|:-----------------------|:-------------------------------------|:-------------------------------|
| `set`          | имя компонента       | значение компонента    | `{ui}`<br>`{OK}`                     | Установка значения             |
| `click`        | имя компонента       | `1` нажат, `2` отпущен | `{ui}`<br>`{OK}`                     | Клик                           |
| `cli`          | `'cli'`              | текст                  | `{OK}`                               | Отправка текста из консоли     |
| `delete`       | путь файла           |                        | `{fsbr}`<br>`{ERR}`                  | Удалить файл                   |
| `rename`       | путь файла           | новый путь файла       | `{fsbr}`<br>`{ERR}`                  | Переименовать/переместить файл |
| `fetch`        | путь файла           |                        | `{fetch_start}`<br>`{fetch_err}`     | Скачать файл                   |
| `upload`       | путь файла           |                        | `{upload_start}`<br>`{upload_err}`   | Начать загрузку файла          |
| `upload_chunk` | `'next'`<br>`'last'` | данные                 | `{upload_next_chunk}`<br>`{upload_end}`<br>`{upload_err}`    | Загрузка файла                 |
| `ota`          | `'flash'`<br>`'fs'`  |                        | `{ota_start}`<br>`{ota_err}`         | Начать OTA обновление          |
| `ota_chunk`    | `'next'`<br>`'last'` | данные                 | `{ota_next_chunk}`<br>`{ota_end}`<br>`{ota_err}`             | OTA обновление                 |
| `ota_url`      | `'flash'`<br>`'fs'`  | ссылка                 | `{OK}`<br>`{ERR}`                    | Начать OTA обновление из URL   |

Пакеты, отправляемые по инициативе устройства
- `{print}` - печать в консоль
- `{update}` - пакет обновлений
- `{push}` - уведомление

</details>