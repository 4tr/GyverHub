## Основные понятия
- **Приложение**, **сайт GyverHub** - тут всё понятно
- **Клиент** - приложение/сайт, на котором открыта панель управления, т.е. приложение подключено и отправляет запросы на устройство
- **ID клиента** - уникальное имя клиента, генерируется при первом запуске приложения, можно изменить в настройках. *Только английские буквы, цифры и знак подчёркивания, максимум 8 символов*
- **Префикс** - уникальное имя сети устройств, должно быть одинаковым у всех устройств и у приложения, чтобы они могли общаться друг с другом: *только английские буквы, цифры и знак подчёркивания*
- **Устройство** - микроконтроллер с библиотекой GyverHub
- **Список устройств** - главный экран приложения
- **Панель управления** - графический интерфейс, экран с элементами управления в приложении, который открывается при выборе устройства из списка устройств 
- **Экран информации** - экран, который открывается при нажатии на кнопку "инфо" в панели управления
- **Файловой менеджер** - экран, который открывается при нажатии на кнопку "папка" в панели управления
- **Компонент** - элемент панели управления
- **Имя компонента** - уникальное в пределах панели управления имя компонента: *только английские буквы, цифры и знак подчёркивания*

## Билдер
### Основная информация
**Билдер** - функция в программе для микроконтроллера, внутри которой собираются компоненты панели управления. В данной библиотеке, в отличие от [GyverPortal](https://github.com/GyverLibs/GyverPortal), билдер и компоненты выполняют сразу несколько функций:
- В билдере "собирается" панель управления - какие компоненты, как расположены и как называются
- В билдере обрабатываются действия с приложения - функция активного компонента вернёт `true`, если пришел запрос на изменение данных
- К активному компоненту может подключаться переменная, которая будет автоматически изменяться библиотекой при изменении значения в приложении
- Чтение текущих значений из подключенных переменных для отправки в приложение или систему умного дома - библиотека сама вызывает билдер когда ей нужно

> Примечание: в билдере не должно быть задержек `delay()` и прочего блокирующего или долго выполняющегося кода! Билдер вызывается в обработчике ответа приложению, во время выполнения билдера приложение ждёт ответа

> Примечание: во время выполнения билдера собирается строка с ответом приложению, поэтому внутри билдера рекомендуется максимально ограничить действия со `String` строками и динамическим выделением памяти (`malloc()`, `new`), а также по возможности использовать `F("строки")` в качестве аргументов функций конструктора

```cpp
void build() {
  // в теле билдера код будет выполняться в любом случае
  foo();

  if (hub.Component()) {
    // внутри условия активного компонента код 
    // будет выполняться только при действии из приложения
    foo();
  }
}
```

### Внешний билдер
Создать функцию и передать объекту библиотеки:
```cpp
GyverHub hub("prefix");

void build() {
  // Компоненты 
}

void setup() {
  hub.onBuild(build);
}
```

### Лямбда билдер
```cpp
GyverHub hub("prefix");

void setup() {
  hub.onBuild([](){
    // Компоненты
  });
}
```

### Лямбда билдер внутри класса
На случай, если нужно обернуть GyverHub в класс
```cpp
class MyClass {
public:
  MyClass() {
    hub.onBuild([this](){
      // Компоненты
    });
  }

  GyverHub hub;
};
```

### Обновление страницы
При открытии панели управления приложение запрашивает актуальный набор компонентов и их значений с устройства. При нажатии на кнопку обновления в панели управления происходит то же самое. Также обновить панель управления можно из билдера, вызвав функцию `.refresh()`:
- Обновление срабатывает только при типе билда `GH_BUILD_ACTION`, то есть при действии в панели управления (клик по кнопке, изменение слайдера) - вызвать можно например по условию срабатывания функции компонента
- Вызов обновления даёт библиотеке команду на отправку пакета с компонентами *после выхода из билдера*. То есть вызывать `refresh()` несколько раз за билдер - безопасно, пакет будет отправлен максимум один раз

```cpp
void build() {
  if (hub.Button("b1")) hub.refresh();
}
```

## Компоненты
### Типы компонентов
Компоненты бывают двух типов:
  - **Активные** - функция вызова компонента возвращает true, если из приложения было изменено значение или нажатие (для кнопок). Например: кнопка, слайдер, поле ввода
  - **Пассивные** - служат для отображения информации. Например: лейбл, "дисплей", светодиод

### Список аргументов
Функции вызова компонентов могут принимать разное количество аргументов, если указывать не все - остальные настройки будут установлены по умолчанию.

### Оптимизация строк
В [документации](https://github.com/GyverLibs/GyverHub/wiki) приведён сокращённый список аргументов. На деле имена, названия компонентов и текстовые значения принимают как `String`, так и `F-строки`. Строки вида `F("строка")` не занимают места в оперативной памяти, а при использовании `F-строк` и в имени, и в названии код будет работать быстрее, так как строки будут сразу прибавляться к пакету без создания промежуточных `String` строк. Пример:
```cpp
LED("имя", 0, F("название"));     // будет использована "медленная" версия функции
LED(F("имя"), 0, F("название"));  // будет использована "быстрая" версия функции
```

Для установки строковых значений "по умолчанию" нужно ориентироваться на версию функции, которая будет вызвана. `F-строки` можно заменить нулём `0` или `nullptr`, а `String` - пустой строкой любого вида:

```cpp
LED(F("имя"), 0, "");       // будет использована "медленная" версия функции
LED(F("имя"), 0, nullptr);  // будет использована "быстрая" версия функции
LED(F("имя"), 0, 0);        // будет использована "быстрая" версия функции
```

### Подключение переменной
Переменные "подключаются" к активным компонентам по адресу - `&`. У некоторых компонентов явно указан тип переменной, например к `Button(ИМЯ, bool* var)` (из документации) можно подключить только типа `bool`:

```cpp
bool btn;

void build() {
  hub.Button("btn", &btn);
}
```

У некоторых компонентов тип подключаемой переменной указан как `void*` - в этом случае тип может быть любым из поддерживаемых (см. ниже), а дальше нужно указать сам тип:

```cpp
int16_t sld;
float spin;

void build() {
  hub.Slider("sld", &sld, GH_INT16);
  hub.Spinner("spin", &spin, GH_FLOAT);
}
```

Поддерживаемые типы:
- `GH_NULL` - переменная не подключена 
- `GH_STR` - String строка 
- `GH_CSTR` - массив char[] (cstring строка)
- `GH_BOOL` - bool (1 байт логическая)
- `GH_INT8` - int8_t (1 байт со знаком)
- `GH_UINT8` - uint8_t (1 байт без знака)
- `GH_INT16` - int16_t (2 байта со знаком)
- `GH_UINT16` - uint16_t (2 байта без знака)
- `GH_INT32` - int32_t (4 байта со знаком)
- `GH_UINT32` - uint32_t (4 байта без знака)
- `GH_FLOAT` - float (4 байта плавающее)
- `GH_DOUBLE` - float (4/8 байта плавающее)

> Примечание: не рекомендуется использовать типы по названиям, такие как `int`, `long`, так как на разных платформах они занимают разное количество байт и программа может работать некорректно. Следует указывать явный тип.

> Примечание: для массивов не нужен символ `&` перед именем переменной, т.к. массив уже является указателем сам на себя.

### Не подключать переменную
Если не нужно автоматическое обновление переменной, но нужно передать в функцию компонента другие настройки - адрес переменной можно указать как `0`, а тип - `GH_NULL`:  
```cpp
hub.Input("inp", 0, GH_NULL, "Input");
hub.Button("btn", 0, "Button");
```

### Автоматическое изменение
Подключенная переменная будет автоматически получать новое значение при изменении в панели управления, при этом функция компонента вернёт `true`:
```cpp
if (hub.Slider("sld", &sld, GH_INT16)) {
  // Здесь переменная sld уже имеет новое значение
  // попадаем сюда, если в приложении изменена позиция слайдера
}
```

### Определение установки для группы компонентов
В реальной программе для хранения данных часто используются структуры: структуру потом удобно записать в энергонезависимую память (EEPROM, Flash). Для определения факта изменения нескольких компонентов, чтобы дать команду на сохранение значений в память, можно использовать следующую конструкцию:

```cpp
struct Data {
  bool sw;
  int16_t sld;
  char str[10];
};

Data data;

void build() {
  bool flag = 0;
  flag |= hub.Switch("sw", &data.sw);
  flag |= hub.Spinner("sld", &data.sld, GH_INT16);
  flag |= hub.Input("str", data.str, GH_CSTR);

  if (flag) {
    // Сохранить в память
  }
}
```

В этом примере `flag` получит значение true, если будет действие *хотя бы по одному компоненту*, который к нему приравнивается через `|=`.

### Динамические компоненты
Используя `String`-строки для имён компонентов, можно создавать уникальные имена компонентов в цикле. Например выведем 5 кнопок с именами btn1, btn2...
```cpp
for (int i = 0; i < 5; i++) {
  hub.Button(String(F("btn")) + i);
}
```

В этом же цикле компоненты можно опрашивать на наличие изменений 
```cpp
for (int i = 0; i < 5; i++) {
  if (hub.Switch(String(F("sw")) + i)) {
    // Действие
  }
}
```

Для подключения переменных в таком случае разумно использовать массив:
```cpp
uint16_t sliders[5];

void build() {
  for (int i = 0; i < 5; i++) {
    hub.Slider(String(F("sld")) + i, sliders[i], GH_UINT16);
  }
}
```

> Примечание: для массивов не нужен символ `&` перед именем переменной, т.к. массив уже является указателем сам на себя

### Вкладки
Основная идея вкладок состоит в генерации компонентов по группам, отдельно для каждой вкладки:
- Сам компонент вкладок меняет переменную типа `uint8_t` согласно номеру вкладки, счёт начинается с `0`
- По изменению вкладки библиотека сама обновляет панель управления
- Далее по значению переменной вкладок можно выстроить группы компонентов, через `if` или `switch`:

```cpp
uint8_t tab;

void build() {
  hub.Tabs("tabs", &tab, "Tab 1,Tab2,Tab 3");
  
  switch (tab) {
    case 0:
      hub.Button("btn");
      break;
      
    case 1:
      hub.Switch("sw");
      break;
      
    case 2:
      hub.Slider("sld");
      break;
  }
}
```

В этом случае будут отображаться только компоненты, соответствующие текущей вкладке. Это простой и понятный подход, но билдер не будет иметь доступа к значениям подключенных переменных (для отправки обновлений или в систему умного дома). В библиотеке предусмотрена проверка `.buildRead()`, которая возвращает `true`, если билдер вызван для чтения значения по имени компонента. Конструкцию для вкладок можно переписать с учётом этого:

```cpp
uint8_t tab;
uint8_t sld0, sld1, sld2;

void build() {
  if (hub.Tabs("tabs", &tab, "Tab 1,Tab2,Tab 3")) hub.refresh();
  
  if (tab == 0 || hub.buildRead()) {
      hub.Slider("sld0", &sld0, GH_UINT8);
  }
  if (tab == 1 || hub.buildRead()) {
      hub.Slider("sld1", &sld1, GH_UINT8);
  }
  if (tab == 2 || hub.buildRead()) {
      hub.Slider("sld2", &sld2, GH_UINT8);
  }
}
```
Таким образом в панель управления будут выводиться только соответствующие вкладке компоненты, но библиотека будет иметь доступ ко всем компонентам для чтения подключенных к ним переменных.

### Меню
В приложении на экране устройства есть выпадающее меню (по умолчанию там пункты инфо и файловый менеджер), в него можно добавить свои пункты. Работает это точно так же, как у вкладок, но переменная номера пункта хранится в классе `GyverHub`. Пример:

```cpp
void build() {
  // добавить меню и 
  if (hub.Menu(F("button,switch,slider"))) {
    Serial.println(hub.menu);   // вывести номер пункта при нажатии
  }

  // отрисовка нужных компонентов
  // согласно пункту меню
  switch (hub.menu) {
    case 0:
      hub.Button("btn");
      break;
      
    case 1:
      hub.Switch("sw");
      break;
      
    case 2:
      hub.Slider("sld");
      break;
  }
}
```

> Компонент `Menu` можно вызывать в любом месте билдера, но только один раз

## Дополнительные модули
### ПИН код
Устройству можно задать пин-код, который нужен будет ввести в приложении при открытии панели управления. `.setPIN(uint32_t pin)` - число должно быть больше `1000`, максимум 9 цифр, не должно начинаться с нуля `0`. 

> Примечание: *на сайте GyverHub* пин-код не является надёжной защитой и очень легко взламывается даже при небольших навыках программирования, так как система работает в браузере и все данные "торчат наружу"

### Таймер GHtimer
В библиотеке имеется простой периодический таймер для нужд основной программы (периодическая отправка обновлений, логов, вывод в консоль и т.д.). Функция `ready()` вернёт `true`, если таймер сработал:

```cpp
GHtimer tmr1;       // глобальный

void setup() {
  tmr1.start(500);  // период 500 мс
}

void loop() {
  // статический, на 10 секунд
  static GHtimer tmr2(0, 10);
  if (tmr2.ready()) Serial.println("tmr2");

  // можно опрашивать готовность без ready()
  if (tmr1) Serial.println("tmr1");
}
```

### Цвет GHcolor
`GHcolor` - структура, которая хранит 24-бит цвет в 8-бит полях `r`, `g`, `b`, а также может принимать и выдавать его в 24-битное представлении:

```cpp
GHcolor red(255, 0, 0);
GHcolor green(0xff00);
GHcolor pink;
pink.setHEX(0xff00ff);

Serial.println(red.getHEX(), HEX);
Serial.print(red.r);
Serial.print(',');
Serial.print(red.g);
Serial.print(',');
Serial.println(red.b);

Serial.println(green.getHEX(), HEX);
Serial.println(pink.getHEX(), HEX);
```

### Тип времени Stamp
Stamp - [библиотека](https://github.com/GyverLibs/Stamp) для хранения и манипуляций со временем. Объект типа `Stamp` можно передать в компоненты `Date`, `Time` и `DateTime` в качестве переменной для хранения времени:

```cpp
#include <Stamp.h>
Stamp gdate;

void build() {
  hub.Date(F("date"), &gdate);
}
```

### Лог GHlog
В библиотеке имеется оффлайн-логгер, позволяющий вести логи пока клиент не подключен и выводить их в специальном компоненте. Лог наследует `Stream`, что позволяет писать в него при помощи `print()`/`println()` любые данные:

```cpp
GHlog mylog;

void build() {
    hub.Log(F("log"), &dlog);   // отправить
}

void setup() {
    // ...
    mylog.begin(200);   // указать размер, умолч. 64
}

void loop() {
    mylog.print("Hello diary! #");
    mylog.println(millis());
    delay(2000);
}
```