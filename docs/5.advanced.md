## Запуск из памяти ESP
Сайт может работать из памяти ESP8266/32: в библиотеке для этого уже настроен веб-сервер, а главная страница хранится в памяти программы. Для работы сайта нужно загрузить в файловую систему папку `hub`, которую можно найти по пути `/web/esp/` в папке с библиотекой. Это можно сделать через плагин для Arduino IDE, через встроенный инструмент в PlatformIO, а также через файловый менеджер на сайте GyverHUB. Файлы должны располагаться в памяти по пути:
- `/hub/script.js.gz`
- `/hub/style.css.gz`

Для открытия esp-версии сайта достаточно зайти на IP адрес платы `http://x.x.x.x/`.

### Особенности ESP версии
- Убраны модули MQTT, Bluetooth, Serial

## Инструменты отладки
### События
Библиотека позволяет отлавливать системные события, для этого нужно подключить функцию вида `f(GHevent_t event, GHconn_t conn)`, например:

```cpp
void setup() {
  hub.onEvent([](GHevent_t event, GHconn_t conn){
    Serial.println(event);  // код события
    Serial.println(conn);   // код подключения
  });
}
```

Для вывода текста вместо кодов (текст хранится в Flash памяти) можно использовать встроенные функции:
```cpp
Serial.print(GHreadConn(conn));
Serial.print(": ");
Serial.println(GHreadEvent(event));
```

> Эти функции возвращают тип `const __FlashStringHelper*`

### Информация о билде
Можно получить полную информацию о текущем билде - зачем он вызван, кем, с какими параметрами и прочее. Для этого нужно в начале билда (перед компонентами) получить информацию в тип данных вида `GHbuild`:

```cpp
void build() {
  GHbuild b = hub.getBuild();
}
```

*Для чтения* доступны поля:
- `b.type` - тип билда, `GHbuild_t`
- `b.hub.id` - ID клиента, с которого пришел запрос, 8 символов
- `b.hub.conn` - тип соединения с клиентом, `GHconn_t`
- `b.action.type` - тип действия, `GHaction_t`
- `b.action.name` - имя компонента (для set и click)
- `b.action.value` - значение (для set)
Можно использовать для отладки, для ручной работы с компонентами, а также для создания "белого списка" клиентов, которые имеют право на доступ к компонентам.

### Причина перезагрузки
Для определения причины перезагрузки можно подключить функцию вида `f(GHreason_t reason)`:

```cpp
void setup() {
  hub.onReboot([](GHreason_t reason){
    Serial.println(reason);  // код события
  });
}
```

- `GH_REB_BUTTON` - по кнопке с сайта
- `GH_REB_OTA` - после ОТА обновления
- `GH_REB_OTA_URL` - после OTA обновления по URL

> Для вывода события в виде текста можно использовать встроенную функцию: `Serial.println(GHreadReason(reason))`

### Наличие соединения
#### Со стороны приложения
При открытой панели управления приложение периодически посылает запросы на устройство. Если устройство не ответит - верхняя панель приложения загорится красным цветом - потеряно соединение с устройством. Пока вращается иконка обновления страницы - приложение ожидает ответа от устройства, таким образом можно контролировать качество соединения.

#### Со стороны устройства
Функция `.focused()` вернёт `true`, если клиент подключен к устройству по любому из способов связи. Для определения текущих подключений можно передать их в функцию, например `.focused(GH_MQTT)` вернёт `true`, если по MQTT есть подключение. Система поддерживает работу одновременно с несколькими клиентами по всем способам связи.

#### MQTT
Для определения наличия соединения с MQTT брокером можно опросить функцию `.online()` - вернёт `true` при наличии подключения к брокеру.

## Дополнительные модули
### Таймер GHtimer
В библиотеке имеется простой периодический таймер для нужд основной программы (периодическая отправка обновлений, логов, вывод в консоль и т.д.).
```cpp
GHtimer tmr1;

void setup() {
    tmr1.start(500);     // период 500 мс
}

void loop() {
  static GHtimer tmr2(0, 10);     // таймер на 10 секунд
  if (tmr2.ready()) Serial.println("tmr2");

  if (tmr1.ready()) Serial.println("tmr1");
}
```

### Цвет GHcolor
`GHcolor` - структура, которая хранит 24-бит цвет в 8-бит полях `r`, `g`, `b`, а также может принимать и выдавать его в 24-битное представлении:

```cpp
GHcolor red(255, 0, 0);
GHcolor green(0xff00);
GHcolor pink;
cyan.setHEX(0xff00ff);

Serial.println(red.getHEX(), HEX);
Serial.println(green.getHEX(), HEX);
Serial.println(pink.getHEX(), HEX);
```

### Тип времени Stamp
`Stamp` - Библиотека для хранения и манипуляций со временем - [документация](https://github.com/GyverLibs/Stamp).

### Лог GHlog
В библиотеке имеется оффлайн-логгер, позволяющий вести логи пока клиент не подключен и выводить их в специальном компоненте. Лог наследует `Stream`, что позволяет писать в него при помощи `print()`/`println()` любые данные:

```cpp
GHlog mylog;

void build() {
    hub.Log(F("log"), &dlog);   // отправить
}

void setup() {
    // ...
    mylog.begin(200);   // указать размер, умолч. 64
}

void loop() {
    mylog.print("Hello diary! #");
    mylog.println(millis());
    delay(2000);
}
```