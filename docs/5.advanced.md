## База проектов
В приложении есть вкладка Projects - список проектов на базе GyverHub. Как добавить свой проект в базу - читай [тут](https://github.com/GyverLibs/GyverHub-projects)

## OTA обновление с GitHub
GyverHub имеет встроенный механизм контроля версий и обновления прошивки с git: если приложение увидит новую версию прошивки для проекта, то предложит обновиться, обновление происходит "по воздуху" файлом из репозиторя. Для включения этого механизма в своём проекте нужно создать репозиторий проекта на GitHub и указать его в библиотеке.

### Репозиторий
Нужно зарегистрировать аккаунт на GitHub, создать репозиторий проекта и загрузить в него файлы.

### Прошивка
Загрузить скомпилированную прошивку (бинарник) в репозиторий по пути `/bin/firmware.bin`
- Можно загрузить gzip-сжатый вариант `/bin/firmware.bin.gz`, если в прошивке указан `ATOMIC_FS_UPDATE`. Приложение само определит, какой файл (.bin или .gz) нужно прошивать

### Файл информации 
Создать и заполнить файл информации о проекте в репозитории по пути `/project.json`. Образец:
```json
{
  "version": "1.0",
  "notes": "комментарии к версии обновления",
  "about": "Краткое описание проекта"
}
```

- Код версии будет проверяться приложением и сравниваться с текущей версией прошивки. Также код версии отображается в списке проектов в приложении, если проект добавлен в базу
- Комментарий к версии показывается в приложении в уведомлении о наличии более свежей версии проекта. Можно оставить пустую строку, если это не нужно. Для переноса строки используй `\n`, например `"notes": "строка 1\nстрока 2"`
- Краткое описание проекта отображается в списке проектов в приложении, если проект добавлен в базу. Если не добавлен - можно не указывать

### Указание версии
Чтобы приложение знало, что для устройства нужно искать обновление, нужно установить текущую версию проекта в прошивке при помощи функции `setVersion()` следующим образом: `hub.setVersion("аккаунт/репозиторий@версия")`, например `"AlexGyver/TachoLED@1.0"`

### Обновление
- Обновить код версии в `.setVersion()` в прошивке
- Обновить код версии в project.json
- Сбилдить и загрузить в репозиторий свежий бинарник

Платформа GyverHub предложит юзеру обновиться при открытии панели управления

## ПИН код
Устройству можно задать пин-код, который нужен будет ввести в приложении при открытии панели управления. `.setPIN(uint32_t pin)` - число должно быть больше `1000`, максимум 9 цифр, не должно начинаться с нуля `0`. 

> Примечание: *на сайте GyverHub* пин-код не является надёжной защитой и очень легко взламывается даже при небольших навыках программирования, так как система работает в браузере и все данные "торчат наружу". В нативном мобильном приложении взломать пароль будет уже гораздо сложнее.

## Дополнительные классы
### Таймер GHtimer
В библиотеке имеется простой периодический таймер для нужд основной программы (периодическая отправка обновлений, логов, вывод в консоль и т.д.). Функция `ready()` вернёт `true`, если таймер сработал:

```cpp
GHtimer tmr1;       // глобальный

void setup() {
  tmr1.start(500);  // период 500 мс
}

void loop() {
  // статический, на 10 секунд
  static GHtimer tmr2(0, 10);
  if (tmr2.ready()) Serial.println("tmr2");

  // можно опрашивать готовность без ready()
  if (tmr1) Serial.println("tmr1");
}
```

### Цвет GHcolor
`GHcolor` - структура, которая хранит 24-бит цвет в 8-бит полях `r`, `g`, `b`, а также может принимать и выдавать его в 24-битное представлении:

```cpp
GHcolor red(255, 0, 0);
GHcolor green(0xff00);
GHcolor pink;
pink.setHEX(0xff00ff);

Serial.println(red.getHEX(), HEX);
Serial.print(red.r);
Serial.print(',');
Serial.print(red.g);
Serial.print(',');
Serial.println(red.b);

Serial.println(green.getHEX(), HEX);
Serial.println(pink.getHEX(), HEX);
```

### Тип времени Stamp
Stamp - [библиотека](https://github.com/GyverLibs/Stamp) для хранения и манипуляций со временем. Объект типа `Stamp` можно передать в компоненты `Date`, `Time` и `DateTime` в качестве переменной для хранения времени:

```cpp
#include <Stamp.h>
Stamp gdate;

void build() {
  hub.Date(&gdate);
}
```

### Лог GHlog
В библиотеке имеется оффлайн-логгер, позволяющий вести логи пока клиент не подключен и выводить их в специальном компоненте. Лог наследует класс `Print`, что позволяет писать в него при помощи `print()`/`println()` любые данные:

```cpp
GHlog mylog;

void build() {
    hub.Log(&dlog);   // отправить
}

void setup() {
    // ...
    mylog.begin(200);   // указать размер, умолч. 64
}

void loop() {
    mylog.print("Hello diary! #");
    mylog.println(millis());
    delay(2000);
}
```

## Инструменты отладки
### События
Библиотека позволяет отлавливать системные события, для этого нужно подключить функцию вида `f(GHevent_t event, GHconn_t conn)`, например:

```cpp
void setup() {
  hub.onEvent([](GHevent_t event, GHconn_t conn){
    Serial.println(event);  // код события
    Serial.println(conn);   // код подключения
  });
}
```

Для вывода текста вместо кодов (текст хранится в Flash памяти) можно использовать встроенные функции:
```cpp
Serial.print(GHreadConn(conn));
Serial.print(": ");
Serial.println(GHreadEvent(event));
```

> Эти функции возвращают тип `const __FlashStringHelper*`

### Информация о билде
Можно получить полную информацию о текущем билде - зачем он вызван, кем, с какими параметрами и прочее. Для этого нужно в начале билда (перед компонентами) получить информацию в тип данных вида `GHbuild`:

```cpp
void build() {
  GHbuild b = hub.getBuild();
}
```

*Для чтения* доступны поля:
- `b.type` - тип билда, `GHbuild_t`
- `b.hub.id` - ID клиента, с которого пришел запрос, 8 символов
- `b.hub.conn` - тип соединения с клиентом, `GHconn_t`
- `b.action.name` - имя компонента (для set и click) как `char*`
- `b.action.nameString()` - имя как String
- `b.action.value` - значение (для set) как `char*`
- `b.action.valueInt()` - значение как целое (32 бит)
- `b.action.valueFloat()` - значение как float
- `b.action.valueString()` - значение как String

Можно использовать для отладки, для ручной работы с компонентами, а также для создания "белого списка" клиентов, которые имеют право на доступ к компонентам.

### Информация о действии
Внутри билдера можно вызвать `hub.action()` - функция вернёт текущее действие типа `GHaction`, из которого можно получить имя и значение компонента для ручной обработки как описано выше. Например:
```cpp
  Serial.println(hub.action().nameString());
  Serial.println(hub.action().valueFloat());
```

### Причина перезагрузки
Для определения причины перезагрузки можно подключить функцию вида `f(GHreason_t reason)`:

```cpp
void setup() {
  hub.onReboot([](GHreason_t reason){
    Serial.println(reason);  // код события
  });
}
```

- `GH_REB_BUTTON` - по кнопке с сайта
- `GH_REB_OTA` - после ОТА обновления
- `GH_REB_OTA_URL` - после OTA обновления по URL

> Для вывода события в виде текста можно использовать встроенную функцию: `Serial.println(GHreadReason(reason))`

### Наличие соединения
#### Со стороны приложения
При открытой панели управления приложение периодически посылает запросы на устройство. Если устройство не ответит - верхняя панель приложения загорится красным цветом - потеряно соединение с устройством. Пока вращается иконка обновления страницы - приложение ожидает ответа от устройства, таким образом можно контролировать качество соединения.

#### Со стороны устройства
Функция `.focused()` вернёт `true`, если клиент подключен к устройству по любому из способов связи. Для определения текущих подключений можно передать их в функцию, например `.focused(GH_MQTT)` вернёт `true`, если по MQTT есть подключение. Система поддерживает работу одновременно с несколькими клиентами по всем способам связи.

#### MQTT
Для определения наличия соединения с MQTT брокером можно опросить функцию `.online()` - вернёт `true` при наличии подключения к брокеру.