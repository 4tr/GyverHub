## Canvas (холст)
В библиотеке есть возможность "рисовать" в окне браузера командами с устройства при помощи HTML Canvas. Сетевой трафик минимизирован до коротких команд, так что отправка даже больших пакетов графики не потребляет много помяти. Также частично реализован [Processing API](https://processing.org/reference/) как более удобный для рисования, чем нативный [HTML Canvas API](https://www.w3schools.com/tags/ref_canvas.asp). Примеры использования:
- Вывод кастомных "графиков"
- Вывод схемы/карты помещения с точками интереса
- Графическое представление показаний датчика (наклон, уровень жидкости...)
- Отображение позиции "головки" станка и прочих механизмов

### Особенности
- Независимо от указанного размера холста он будет отмасштабирован по ширине, а высота будет задана пропорционально. Таким образом графика на холсте будет выглядеть одинаково при любом размере экрана или виджета, а размер холста задаётся для удобства программиста, чтобы ориентироваться в своих цифрах
- Холст не перестраивается при изменении ширины окна браузера и сохраняет выведенную графику. Обновляется и перестраивается под новую ширину только при обновлении панели управления
- Начало координат - левый верхний угол
- Отрицательные числа при задании координат графики вычитаются из ширины холста, таким образом `point(-1, -1)` установит точку в правый нижний угол
- Список функций см. на главной странице [документации](https://github.com/GyverLibs/GyverHUB/wiki)

### Создание холста
Холст создаётся в билдере как обычный компонент. Холст может быть виджетом, ширина виджета также к нему применяется:
```cpp
void build() {
  hub.Canvas(F("cv1"));           // пустой холст, 400x300px
  hub.Canvas(F("cv2"), 600, 600); // пустой холст 600x600px
}
```

### Рисование в билдере
Для рисования внутри билдера нужно соблюдать следующий порядок вызова функций:
- Создать объект холста `GHcanvas`
- Передать его в `BeginCanvas()`
- Рисовать
- Вызвать `EndCanvas()`

> Функции вывода графики, вызванные внутри билдера, добавляют данные сразу к буферу билдера и не создают новых строк, что уменьшает расход и фрагментацию памяти

```cpp
void build() {
  GHcanvas cv;                              // создать холст
  hub.BeginCanvas(F("cv"), 300, 300, &cv);  // начать рисование
  // линии крест-накрест
  cv.line(0, 0, -1, -1);
  cv.line(0, -1, -1, 0);
  hub.EndCanvas();                          // закончить
}
```

### Рисование "на лету"
На созданном в билдере холсте можно рисовать из основного цикла программы, по таймеру или событям. Для рисования нужно соблюдать следующий порядок вызова функций:
- Создать объект холста `GHcanvas`
- Передать холст в `sendCanvasBegin()` с указанием имени существующего холста
- Рисовать
- Передать холст в `sendCanvasEnd()`

```cpp
void loop() {
  static GHtimer tmr(300);
  if (tmr.ready()) {
    GHcanvas cv;                        // создать холст
    hub.sendCanvasBegin(F("cv2"), cv);  // начать отправку
    // вывести круг случайного цвета в случайном месте
    cv.fill(GHcolor(random(255), random(255), random(255)), random(100, 255));
    cv.circle(random(0, 600), random(0, 600), random(10, 50));
    hub.sendCanvasEnd(cv);              // закончить отправку
  }
}
```

### Текстовые команды
Команды рисования можно вводить в текстовом виде в функцию `.custom()`. Особенности:
- В браузере текущий canvas всегда называется `cv`, а его контекст - `cx`
- Для ввода строковых значений допускаются как одинарные кавычки `'`, так и двойные `\"`. Библиотека сама делает им *escape*
- Область видимости созданных переменных - только внутри строки с командой!

Пример с градиентом:
```cpp
GHcanvas cv;
cv.custom(F("let grd=cx.createLinearGradient(0,0,200,0);"
"grd.addColorStop(0,'red');"
"grd.addColorStop(1,'white');"
"cx.fillStyle = grd;"));
cv.fillRect(0, 0, -1, -1);
```
Выведет горизонтальный градиент от красного к белому на весь холст.

Пример вывода изображения:
```cpp
cv1.custom(F("let img = new Image;"
"img.src='https://www.w3schools.com/tags/img_the_scream.jpg';"
"img.onload = function(){cx.drawImage(img,0,0);};"));
```

## Инструменты отладки
### События
Библиотека позволяет отлавливать системные события, для этого нужно подключить функцию вида `f(GHevent_t event, GHconn_t conn)`, например:

```cpp
void setup() {
  hub.onEvent([](GHevent_t event, GHconn_t conn){
    Serial.println(event);  // код события
    Serial.println(conn);   // код подключения
  });
}
```

Для вывода текста вместо кодов (текст хранится в Flash памяти) можно использовать встроенные функции:
```cpp
Serial.print(GHreadConn(conn));
Serial.print(": ");
Serial.println(GHreadEvent(event));
```

> Эти функции возвращают тип `const __FlashStringHelper*`

### Информация о билде
Можно получить полную информацию о текущем билде - зачем он вызван, кем, с какими параметрами и прочее. Для этого нужно в начале билда (перед компонентами) получить информацию в тип данных вида `GHbuild`:

```cpp
void build() {
  GHbuild b = hub.getBuild();
}
```

*Для чтения* доступны поля:
- `b.type` - тип билда, `GHbuild_t`
- `b.hub.id` - ID клиента, с которого пришел запрос, 8 символов
- `b.hub.conn` - тип соединения с клиентом, `GHconn_t`
- `b.action.type` - тип действия, `GHaction_t`
- `b.action.name` - имя компонента (для set и click)
- `b.action.value` - значение (для set)
Можно использовать для отладки, для ручной работы с компонентами, а также для создания "белого списка" клиентов, которые имеют право на доступ к компонентам.

### Причина перезагрузки
Для определения причины перезагрузки можно подключить функцию вида `f(GHreason_t reason)`:

```cpp
void setup() {
  hub.onReboot([](GHreason_t reason){
    Serial.println(reason);  // код события
  });
}
```

- `GH_REB_BUTTON` - по кнопке с сайта
- `GH_REB_OTA` - после ОТА обновления
- `GH_REB_OTA_URL` - после OTA обновления по URL

> Для вывода события в виде текста можно использовать встроенную функцию: `Serial.println(GHreadReason(reason))`

### Наличие соединения
#### Со стороны приложения
При открытой панели управления приложение периодически посылает запросы на устройство. Если устройство не ответит - верхняя панель приложения загорится красным цветом - потеряно соединение с устройством. Пока вращается иконка обновления страницы - приложение ожидает ответа от устройства, таким образом можно контролировать качество соединения.

#### Со стороны устройства
Функция `.focused()` вернёт `true`, если клиент подключен к устройству по любому из способов связи. Для определения текущих подключений можно передать их в функцию, например `.focused(GH_MQTT)` вернёт `true`, если по MQTT есть подключение. Система поддерживает работу одновременно с несколькими клиентами по всем способам связи.

#### MQTT
Для определения наличия соединения с MQTT брокером можно опросить функцию `.online()` - вернёт `true` при наличии подключения к брокеру.

## Дополнительные модули
### Таймер GHtimer
В библиотеке имеется простой периодический таймер для нужд основной программы (периодическая отправка обновлений, логов, вывод в консоль и т.д.).
```cpp
GHtimer tmr1;

void setup() {
    tmr1.start(500);     // период 500 мс
}

void loop() {
  static GHtimer tmr2(0, 10);     // таймер на 10 секунд
  if (tmr2.ready()) Serial.println("tmr2");

  if (tmr1.ready()) Serial.println("tmr1");
}
```

### Цвет GHcolor
`GHcolor` - структура, которая хранит 24-бит цвет в 8-бит полях `r`, `g`, `b`, а также может принимать и выдавать его в 24-битное представлении:

```cpp
GHcolor red(255, 0, 0);
GHcolor green(0xff00);
GHcolor pink;
pink.setHEX(0xff00ff);

Serial.println(red.getHEX(), HEX);
Serial.print(red.r);
Serial.print(',');
Serial.print(red.g);
Serial.print(',');
Serial.println(red.b);

Serial.println(green.getHEX(), HEX);
Serial.println(pink.getHEX(), HEX);
```

### Тип времени Stamp
`Stamp` - Библиотека для хранения и манипуляций со временем - [документация](https://github.com/GyverLibs/Stamp).

### Лог GHlog
В библиотеке имеется оффлайн-логгер, позволяющий вести логи пока клиент не подключен и выводить их в специальном компоненте. Лог наследует `Stream`, что позволяет писать в него при помощи `print()`/`println()` любые данные:

```cpp
GHlog mylog;

void build() {
    hub.Log(F("log"), &dlog);   // отправить
}

void setup() {
    // ...
    mylog.begin(200);   // указать размер, умолч. 64
}

void loop() {
    mylog.print("Hello diary! #");
    mylog.println(millis());
    delay(2000);
}
```