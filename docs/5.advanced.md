## Canvas (холст)
В библиотеке есть возможность "рисовать" в окне браузера командами с устройства при помощи HTML Canvas, а также получать координаты кликов по холсту, что даёт безграничные возможности по визуализации данных и взаимодействию с ними. Сетевой трафик минимизирован до коротких команд, так что отправка даже больших пакетов графики не потребляет много помяти. Также частично реализован [Processing API](https://processing.org/reference/) как более удобный для рисования, чем нативный [HTML Canvas API](https://www.w3schools.com/tags/ref_canvas.asp). Примеры использования:
- Вывод кастомных "графиков"
- Вывод схемы/карты помещения с точками интереса
- Графическое представление показаний датчика (наклон, уровень жидкости...)
- Отображение позиции "головки" станка или других механизмов и их частей
- Удалённый "тачпад" для управления устройством

### Особенности API
- Независимо от указанного в программе размера холст будет пропорционально отмасштабирован и вписан в свой контейнер (по ширине UI или внутри виджета), также масштаб будет увеличен на устройствах с увеличенной плотностью пикселей. Таким образом графика на холсте будет выглядеть одинаково и чётко при любом размере экрана или виджета, а *виртуальный* размер холста задаётся для удобства программиста, чтобы ориентироваться в размере своего холста. В то же время реальный размер холста в пикселях будет отличаться от "виртуального" размера, заданного в программе (подробнее ниже)!
- Холст не перестраивается при изменении ширины окна браузера и сохраняет выведенную графику. Обновляется и перестраивается под новую ширину он только при обновлении панели управления
- Начало координат - левый верхний угол, ось Y направлена вниз
- Отрицательные числа при задании координат графики **через функции GHcanvas** (не через кастомный js код) вычитаются из ширины холста, таким образом `point(-1, -1)` установит точку в правый нижний угол
- Список функций см. на главной странице [документации](https://github.com/GyverLibs/GyverHUB/wiki)

### Создание холста
Холст создаётся в билдере как обычный компонент. Холст может быть виджетом, ширина виджета также к нему применяется:
```cpp
void build() {
  hub.Canvas(F("cv1"));           // пустой холст, 400x300px
  hub.Canvas(F("cv2"), 600, 600); // пустой холст 600x600px
}
```

### Рисование в билдере
Для рисования внутри билдера нужно соблюдать следующий строгий порядок вызова функций:
1. Создать объект холста `GHcanvas`
2. Передать его в `BeginCanvas()`
3. Рисовать
4. Вызвать `EndCanvas()`

> Между созданием `GHcanvas` и завершением рисования `EndCanvas()` категорически не должно быть других функций компонентов!

> Функции вывода графики, вызванные внутри билдера, добавляют данные сразу к буферу билдера и не создают новых строк, что уменьшает расход и фрагментацию памяти

```cpp
void build() {
  GHcanvas cv;                              // создать холст
  hub.BeginCanvas(F("cv"), 300, 300, &cv);  // начать рисование
  // линии крест-накрест
  cv.line(0, 0, -1, -1);
  cv.line(0, -1, -1, 0);
  hub.EndCanvas();                          // закончить
}
```

### Рисование "на лету"
На созданном в билдере холсте можно рисовать из основного цикла программы, по таймеру или событям. Для рисования нужно соблюдать следующий порядок вызова функций:
1. Создать объект холста `GHcanvas`
2. Передать холст в `sendCanvasBegin()` с указанием имени существующего холста
3. Рисовать
4. Передать холст в `sendCanvasEnd()`

```cpp
void loop() {
  static GHtimer tmr(300);
  if (tmr.ready()) {
    GHcanvas cv;                        // создать холст
    hub.sendCanvasBegin(F("cv2"), cv);  // начать отправку
    // вывести круг случайного цвета в случайном месте
    cv.fill(GHcolor(random(255), random(255), random(255)), random(100, 255));
    cv.circle(random(0, 600), random(0, 600), random(10, 50));
    hub.sendCanvasEnd(cv);              // закончить отправку
  }
}
```

#### Рисование по действию
Функции рисования на холсте внутри билдера работают только в том случае, если билдер вызван для сборки панели управления. Если билдер вызван для обработки действия - *функции рисования в теле билдера игнорируются*. Но внутри условия компонента они будут работать, таким образом можно отправлять обновления холста по действиям с компонентов. Пример: по клику по кнопке добавлять кружочки на холст с изначальным рисунком:

```cpp
void build() {
  if (hub.Button(F("b1"))) {            // клик по кнопке (обработка действия)
    GHcanvas cv;                        // создать холст
    hub.sendCanvasBegin(F("cv"), cv);   // начать отправку
    // случайный кружок
    cv.circle(random(0, 30) * 10, random(0, 30) * 10, random(5, 30));
    hub.sendCanvasEnd(cv);              // закончить отправку
  }

  GHcanvas cv;                              // создать холст
  hub.BeginCanvas(F("cv"), 300, 300, &cv);  // начать рисование
  // это рисование будет выполнено только при сборке панели управления
  cv.line(0, 0, -1, -1);                    // линии крест-накрест
  cv.line(0, -1, -1, 0);
  hub.EndCanvas();                          // закончить
}
```

### Обработка кликов
GyverHUB позволяет получить координаты кликов мышкой (и касания пальцем) по холсту в координатах заданного в программе размера холста. Для этого нужно создать переменную обработчика позиции типа `GHpos` и подключить её к компоненту холста. Компонент холста вернёт `true`, если в приложении был клик по холсту. С переменной можно получить координаты из `x()` и `y()`:

```cpp
GHpos pos;
GHcanvas cv;
if (hub.BeginCanvas(F("cv"), 400, 600, &cv, &pos)) {
  Serial.println(pos.x());
  Serial.println(pos.y());
}
// рисование если нужно
```

Если действия по клику с холста должны приводить к выполнению какого-то объёмного кода, то лучше вынести обработку из билдера в основной цикл программы, а переменную позиции создать глобально. В таком случае узнать о факте клика можно из флага `changed()`:

```cpp
GHpos pos;

void build() {
  // ...
  GHcanvas cv;
  hub.BeginCanvas(F("cv"), 400, 600, &cv, &pos);
  // ...
}

void loop() {
  // ...
  if (pos.changed()) {
    Serial.println(pos.x());
    Serial.println(pos.y());

    // выведем кружок в точку клика
    GHcanvas cv;                        // создать холст
    hub.sendCanvasBegin(F("cv"), cv);   // начать отправку
    // случайный кружок
    cv.circle(pos.x(), pos.y(), 10);
    hub.sendCanvasEnd(cv);              // закончить отправку
  }
  // ...
}
```

В то же время можно реагировать на клики прямо в билдере:
```cpp
void build() {
  GHcanvas cv;
  GHpos pos;  // создадим локально, глобально в этом случае не нужно

  if (hub.BeginCanvas(F("cv"), 400, 600, &cv, &pos)) {
    // сюда попадаем при клике по холсту
    // для рисования нужно создать новый холст!
    GHcanvas cv0;
    hub.sendCanvasBegin(F("cv"), cv0);
    cv0.circle(pos.x(), pos.y(), 10);   // кружок в точку клика
    hub.sendCanvasEnd(cv0);
  }

  // рисуем ...
  // рисование работает только при загрузке панели управления
  hub.EndCanvas();
}
```

### Текстовые команды
Свои [команды рисования](https://www.w3schools.com/tags/ref_canvas.asp) можно вводить в текстовом виде в функцию `.custom()`. Особенности:
- В коде холста текущий *Canvas* всегда называется `cv`, а его *Context* - `cx`
- Не работает задание отрицательных координат, т.к. функции вызываются вне парсера GHcanvas API
- Для ввода строковых значений допускаются как одинарные кавычки (`'`/`\'`), так и двойные (`"`/`\"`). Библиотека сама делает им *escape*
- Область видимости созданных переменных - внутри всего блока между созданием `GHcanvas` и его отправкой/завершением
- В области видимости холста есть функция `scale()`, при помощи которой можно привести виртуальные координаты к реальным. Нужно просто умножить значение на эту функцию

Пример с горизонтальным градиентом от красного к белому на весь холст:
```cpp
GHcanvas cv;
hub.BeginCanvas(F("cv"), 400, 300, &cv);
// градиент шириной 400 виртуальных пикселей - масштабируем в реальные
cv.custom(F("let grd=cx.createLinearGradient(0,0,400*scale(),0);"
"grd.addColorStop(0,'red');"
"grd.addColorStop(1,'white');"
"cx.fillStyle = grd;"));
cv.fillRect(0, 0, -1, -1);
```

Пример вывода изображения по url, выведется в реальном размере самого изображения
```cpp
cv1.custom(F("let img = new Image;"
"img.src='https://www.w3schools.com/tags/img_the_scream.jpg';"
"img.onload = function(){cx.drawImage(img,0,0);};"));
```

В следующем примере масштабируем изображение под ширину 200 пикселей
```cpp
cv1.custom(F("let img = new Image;"
"img.src='https://www.w3schools.com/tags/img_the_scream.jpg';"
"img.onload = function(){cx.drawImage(img,0,0,200*scale(),(200*img.height/img.width)*scale());};"));
```

## Инструменты отладки
### События
Библиотека позволяет отлавливать системные события, для этого нужно подключить функцию вида `f(GHevent_t event, GHconn_t conn)`, например:

```cpp
void setup() {
  hub.onEvent([](GHevent_t event, GHconn_t conn){
    Serial.println(event);  // код события
    Serial.println(conn);   // код подключения
  });
}
```

Для вывода текста вместо кодов (текст хранится в Flash памяти) можно использовать встроенные функции:
```cpp
Serial.print(GHreadConn(conn));
Serial.print(": ");
Serial.println(GHreadEvent(event));
```

> Эти функции возвращают тип `const __FlashStringHelper*`

### Информация о билде
Можно получить полную информацию о текущем билде - зачем он вызван, кем, с какими параметрами и прочее. Для этого нужно в начале билда (перед компонентами) получить информацию в тип данных вида `GHbuild`:

```cpp
void build() {
  GHbuild b = hub.getBuild();
}
```

*Для чтения* доступны поля:
- `b.type` - тип билда, `GHbuild_t`
- `b.hub.id` - ID клиента, с которого пришел запрос, 8 символов
- `b.hub.conn` - тип соединения с клиентом, `GHconn_t`
- `b.action.type` - тип действия, `GHaction_t`
- `b.action.name` - имя компонента (для set и click)
- `b.action.value` - значение (для set)
Можно использовать для отладки, для ручной работы с компонентами, а также для создания "белого списка" клиентов, которые имеют право на доступ к компонентам.

### Причина перезагрузки
Для определения причины перезагрузки можно подключить функцию вида `f(GHreason_t reason)`:

```cpp
void setup() {
  hub.onReboot([](GHreason_t reason){
    Serial.println(reason);  // код события
  });
}
```

- `GH_REB_BUTTON` - по кнопке с сайта
- `GH_REB_OTA` - после ОТА обновления
- `GH_REB_OTA_URL` - после OTA обновления по URL

> Для вывода события в виде текста можно использовать встроенную функцию: `Serial.println(GHreadReason(reason))`

### Наличие соединения
#### Со стороны приложения
При открытой панели управления приложение периодически посылает запросы на устройство. Если устройство не ответит - верхняя панель приложения загорится красным цветом - потеряно соединение с устройством. Пока вращается иконка обновления страницы - приложение ожидает ответа от устройства, таким образом можно контролировать качество соединения.

#### Со стороны устройства
Функция `.focused()` вернёт `true`, если клиент подключен к устройству по любому из способов связи. Для определения текущих подключений можно передать их в функцию, например `.focused(GH_MQTT)` вернёт `true`, если по MQTT есть подключение. Система поддерживает работу одновременно с несколькими клиентами по всем способам связи.

#### MQTT
Для определения наличия соединения с MQTT брокером можно опросить функцию `.online()` - вернёт `true` при наличии подключения к брокеру.

## Дополнительные модули
### Таймер GHtimer
В библиотеке имеется простой периодический таймер для нужд основной программы (периодическая отправка обновлений, логов, вывод в консоль и т.д.).
```cpp
GHtimer tmr1;

void setup() {
    tmr1.start(500);     // период 500 мс
}

void loop() {
  static GHtimer tmr2(0, 10);     // таймер на 10 секунд
  if (tmr2.ready()) Serial.println("tmr2");

  if (tmr1.ready()) Serial.println("tmr1");
}
```

### Цвет GHcolor
`GHcolor` - структура, которая хранит 24-бит цвет в 8-бит полях `r`, `g`, `b`, а также может принимать и выдавать его в 24-битное представлении:

```cpp
GHcolor red(255, 0, 0);
GHcolor green(0xff00);
GHcolor pink;
pink.setHEX(0xff00ff);

Serial.println(red.getHEX(), HEX);
Serial.print(red.r);
Serial.print(',');
Serial.print(red.g);
Serial.print(',');
Serial.println(red.b);

Serial.println(green.getHEX(), HEX);
Serial.println(pink.getHEX(), HEX);
```

### Тип времени Stamp
`Stamp` - Библиотека для хранения и манипуляций со временем - [документация](https://github.com/GyverLibs/Stamp).

### Лог GHlog
В библиотеке имеется оффлайн-логгер, позволяющий вести логи пока клиент не подключен и выводить их в специальном компоненте. Лог наследует `Stream`, что позволяет писать в него при помощи `print()`/`println()` любые данные:

```cpp
GHlog mylog;

void build() {
    hub.Log(F("log"), &dlog);   // отправить
}

void setup() {
    // ...
    mylog.begin(200);   // указать размер, умолч. 64
}

void loop() {
    mylog.print("Hello diary! #");
    mylog.println(millis());
    delay(2000);
}
```