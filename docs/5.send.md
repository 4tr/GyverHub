## Отправка обновлений
Библиотека позволяет отправлять в приложение новые значения компонентов, на случай если они меняются где-то в программе (показания датчиков, состояние тумблеров). Обновления отображаются сразу, без обновления страницы в приложении. Отправить обновление можно на любой компонент, за исключением кнопок, заголовка и вкладок.

### Вручную
Для отправки обновления нужно вызвать `.sendUpdate(NAME, VALUE)`, где `NAME` - это имя компонента, `VALUE` - значение. Отправлять данные можно из любого места в программе (из основного цикла программы или из билдера). Компонент с указанным именем должен существовать на странице панели управления. `VALUE` принимает тип `String`, таким образом для отправки численных значений нужно преобразовать их в строку: `.sendUpdate("name", String(value))`. Обновление будет отправлено только в том случае, если панель управления текущим устройством открыта в приложении, библиотека сама следит за этим и отправит обновление всем подключенным клиентам.

В этом примере лейбл обновляется по таймеру, а светодиод - по клику по кнопке в билдере:
```cpp
void build() {
  hub.BeginWidgets();
  hub.WidgetSize(50);
  hub.Label(F("lbl"));

  hub.WidgetSize(25);
  if (hub.Button(F("upd"))) {   // клик по кнопке
    static bool led;
    led = !led;
    hub.sendUpdate("led", String(led)); // обновляем led
  }
  hub.LED(F("led"));
}

void loop() {
  // вывод значения millis() в лейбл lbl раз в секунду
  static GHtimer tmr(1000);
  if (tmr.ready()) hub.sendUpdate("lbl", String(millis()));
}
```

### Автоматически
Вызвать `.sendUpdate(NAME)` - библиотека вызовет билдер, сама прочитает значение указанного компонента и отправит пакет в приложение. Имена компонентов можно передать списком через запятую без пробелов `.sendUpdate("cmp1,cmp2,slider")` - библиотека сформирует пакет обновлений и отправит его в приложение. Это сильно эффективнее, чем отправлять обновления поимённо.

> Обновления по имени не работают внутри функции билдера

## Отправка уведомлений
### Push
С устройства можно отправить пуш-уведомление в браузер, для этого нужно вызвать `.sendPush(текст)`. Для получения уведомлений нужно разрешить их в браузере.
- При включенном MQTT уведомление доходит при любом открытом экране приложения, в отличие от Update обновления
- Уведомления лучше всего доходят при подключении по MQTT: с небольшой задержкой при свёрнутом браузере, с задержкой в несколько секунд при заблокированном экране (для смартфонов)

### Alert
Можно отправить стандартное всплывающее окно с кнопкой ОК при помощи `.sendAlert(текст)`.

### Всплывающее
В приложении есть всплывающее цветное уведомление, его можно вызвать с устройства при помощи функций `.sendNotice(текст)` и `.sendNotice(текст, цвет)`.

## Веб-консоль
В системе есть модуль веб консоли, позволяющий обмениваться текстовыми командами между устройством и приложением, как через Serial монитор. На стороне приложения консоль открывается на экране информации. При открытии консоль всегда очищается. 

### Отправка
На стороне устройства используется функция `.print(текст)` и `.print(текст, цвет)` для отправки текста в приложение. Функция проверяет, по каким способам связи есть подключенные клиенты, и отправляет ответ только им. 

```cpp
void loop() {
  hub.print(String(millis()));
  delay(2000);
}
```

### Приём
Для принятия текста нужно подключить функцию вида `f(String& text)`:

```cpp
void cli(String& text) {
   Serial.println(text);
   hub.print(text);
   // Отправить в serial и обратно в консоль 
}

void setup() {
  hub.onCLI(cli);
}
```

Лямбда-вариант
```cpp
void setup() {
  hub.onCLI([](){
    Serial.println(text);
    hub.print(text);
    // Отправить в serial и обратно в консоль 
  });
}
```

## Инструменты отладки
### События
Библиотека позволяет отлавливать системные события, для этого нужно подключить функцию вида `f(GHevent_t event, GHconn_t conn)`, например:

```cpp
void setup() {
  hub.onEvent([](GHevent_t event, GHconn_t conn){
    Serial.println(event);  // код события
    Serial.println(conn);   // код подключения
  });
}
```

Для вывода текста вместо кодов (текст хранится в Flash памяти) можно использовать встроенные функции:
```cpp
Serial.print(GHreadConn(conn));
Serial.print(": ");
Serial.println(GHreadEvent(event));
```

> Эти функции возвращают тип `const __FlashStringHelper*`

### Информация о билде
Можно получить полную информацию о текущем билде - зачем он вызван, кем, с какими параметрами и прочее. Для этого нужно в начале билда (перед компонентами) получить информацию в тип данных вида `GHbuild`:

```cpp
void build() {
  GHbuild b = hub.getBuild();
}
```

*Для чтения* доступны поля:
- `b.type` - тип билда, `GHbuild_t`
- `b.hub.id` - ID клиента, с которого пришел запрос, 8 символов
- `b.hub.conn` - тип соединения с клиентом, `GHconn_t`
- `b.action.type` - тип действия, `GHaction_t`
- `b.action.name` - имя компонента (для set и click) как `char*`
- `b.action.nameString()` - имя как String
- `b.action.value` - значение (для set) как `char*`
- `b.action.valueInt()` - значение как целое (32 бит)
- `b.action.valueFloat()` - значение как float
- `b.action.valueString()` - значение как String

Можно использовать для отладки, для ручной работы с компонентами, а также для создания "белого списка" клиентов, которые имеют право на доступ к компонентам.

### Информация о действии
Внутри билдера можно вызвать `hub.action()` - функция вернёт текущее действие типа `GHaction`, из которого можно получить имя и значение компонента для ручной обработки как описано выше. Например:
```cpp
  Serial.println(hub.action().nameString());
  Serial.println(hub.action().valueFloat());
```

### Причина перезагрузки
Для определения причины перезагрузки можно подключить функцию вида `f(GHreason_t reason)`:

```cpp
void setup() {
  hub.onReboot([](GHreason_t reason){
    Serial.println(reason);  // код события
  });
}
```

- `GH_REB_BUTTON` - по кнопке с сайта
- `GH_REB_OTA` - после ОТА обновления
- `GH_REB_OTA_URL` - после OTA обновления по URL

> Для вывода события в виде текста можно использовать встроенную функцию: `Serial.println(GHreadReason(reason))`

### Наличие соединения
#### Со стороны приложения
При открытой панели управления приложение периодически посылает запросы на устройство. Если устройство не ответит - верхняя панель приложения загорится красным цветом - потеряно соединение с устройством. Пока вращается иконка обновления страницы - приложение ожидает ответа от устройства, таким образом можно контролировать качество соединения.

#### Со стороны устройства
Функция `.focused()` вернёт `true`, если клиент подключен к устройству по любому из способов связи. Для определения текущих подключений можно передать их в функцию, например `.focused(GH_MQTT)` вернёт `true`, если по MQTT есть подключение. Система поддерживает работу одновременно с несколькими клиентами по всем способам связи.

#### MQTT
Для определения наличия соединения с MQTT брокером можно опросить функцию `.online()` - вернёт `true` при наличии подключения к брокеру.